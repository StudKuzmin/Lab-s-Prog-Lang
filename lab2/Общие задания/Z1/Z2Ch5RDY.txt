#include <ctime>
#include <iostream>
#include <windows.h>
#include "stdio.h"

using namespace std;

int main()
{
    setlocale(LC_ALL, "ru");
    srand(time(0));

    int** m;//Двумерный динамический массив
    int rows, cols;//строки, столбцы
    int** a;
    int** c;
    int n, g;//размерность поля

    cout << "Введите размерность поля игры << Жизнь >>, где 3 - 3х3, 5 - 5х5 и т.д.: ";
    cin >> n;
    rows = cols = n;//строки = столбцы

    HANDLE description = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(description, FOREGROUND_GREEN);//Зелёный цвет
    cout << "\n---------------------------------------------------------------------------------------------------------\n";
    printf("|\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| ОПИСАНИЕ:\t\t\t\t\t\t\t\t\t\t\t\t|\n|\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| В игре << Жизнь >> есть живые клетки(обозначаются как 1) и мёртвые(обозначаются как 0)\t\t|\n|\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| УСЛОВИЯ:\t\t\t\t\t\t\t\t\t\t\t\t|");
    printf("\n| 1) Живая клетка, возле которой меньше двух живых клеток, умирает от одиночества;\t\t\t|");
    printf("\n| 2) Живая клетка, возле которой есть две или три живые клетки, выживает ещё на одно поколение;\t\t|");
    printf("\n| 3) Живая клетка, возле которой находится больше трёх живых клеток, умирает от перенаселения;\t\t|");
    printf("\n| 4) Мёртвая клетка, рядом с которой есть ровно три живых соседа, оживает.\t\t\t\t|");
    cout << "\n---------------------------------------------------------------------------------------------------------\n";

    SetConsoleTextAttribute(description, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN);//Белый цвет
    cout << "Введите число поколений: ";
    cin >> g;
    cout << "Количество поколений: " << g;

    m = new int* [rows];//Создаём динамический массив указателей размером количества СТРОК
    a = new int* [rows];
    c = new int* [rows];

    for (int i = 0; i < rows; i++)
    {
        m[i] = new int[cols];//Присваиваем элементам указателей новые динамические массивы размером количества СТОЛБЦОВ
    }

    for (int i = 0; i < rows; i++)//Заполняем двумерный динамический массив числами
    {
        for (int j = 0; j < cols; j++)
        {
            m[i][j] = rand() % 2;//Ограничиваем значение до 2, где 0 - неживая, 1 - живая.
        }
    }

    //////////////////////// КОПИРУЕМ ЭЛЕМЕНТЫ МАССИВА /////////////////////////////////

    for (int i = 0; i < rows; i++)
    {
        a[i] = new int[cols];//Присваиваем элементам указателей новые динамические массивы размером количества СТОЛБЦОВ
    }

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            a[i][j] = m[i][j];//Копируем элементы
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////

    for (int i = 0; i < rows; i++)
    {
        c[i] = new int[cols];//Присваиваем элементам указателей новые динамические массивы размером количества СТОЛБЦОВ
    }

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            c[i][j] = m[i][j];//Копируем элементы
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////

    cout << "\n\n`````````````````````````````````````````````````````````````````````````````````````````````````````````\n";
    cout << "ПОКОЛЕНИЕ 0: " << endl << endl;
    for (int i = 0; i < rows; i++)//Выводим на экран двумерный динамический массив
    {
        for (int j = 0; j < cols; j++)
        {
            if (m[i][j] == 1)//Меняем цвет живых клеток на красный
            {
                SetConsoleTextAttribute(description, FOREGROUND_RED);
                cout << m[i][j] << "\t";
                SetConsoleTextAttribute(description, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
            }
            else cout << m[i][j] << "\t";
        }
        cout << endl << endl << endl;
    }

    /////////////////////////// ИГРА /////////////////////////////

    int h = 1;
    int p = 0;//Для счёта единиц(живых клеток)
    while (h <= g)//Счёт поколений
    {
        Sleep(1000);
        system("CLS");
        cout << "\n`````````````````````````````````````````````````````````````````````````````````````````````````````````\n";
        cout << "ПОКОЛЕНИЕ: " << h << endl << endl;
        for (int i = 0; i < rows; i++)//Выводим на экран двумерный динамический массив
        {
            for (int j = 0; j < cols; j++)
            {
                if (i == 0 && j == 0)//Верхний левый угол матрицы
                {
                    p = 0;
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == 0 && j == (cols - 1))//Верхний правый угол матрицы
                {
                    p = 0;
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == (rows - 1) && j == 0)//Нижний левый угол матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == (rows - 1) && j == (cols - 1))//Нижний правый угол матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == 0 && j != 0 && j != (cols - 1))//Верхняя граница матрицы
                {
                    p = 0;
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i != 0 && i != (rows - 1) && j == 0)//Левая граница матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == (rows - 1) && j != 0 && j != (cols - 1))//Нижняя граница матрицы
                {
                    p = 0;
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i != 0 && i != (rows - 1) && j == (cols - 1))//Правая граница матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i != 0 && i != (rows - 1) && j != 0 && j != (cols - 1))//Середина матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }

                }
                if (m[i][j] == 1)//Меняем цвет живых клеток на красный
                {
                    SetConsoleTextAttribute(description, FOREGROUND_RED);
                    cout << m[i][j] << "\t";
                    SetConsoleTextAttribute(description, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
                }
                else cout << m[i][j] << "\t";
            }
            cout << endl << endl << endl;
        }

        for (int i = 0; i < rows; i++)//Обновляем копируемый массив
        {
            for (int j = 0; j < cols; j++)
            {
                a[i][j] = m[i][j];
            }
        }
        h++;// + поколение
    }

    system("CLS");
    int answer;
    cout << "Вывести каждое поколение? 1 - да, 0 - нет: ";
    cin >> answer;

    if (answer < 0 || answer > 1)
    {
        while (answer < 0 || answer > 1)
        {
            cout << "Введите один из ответов: 1 - Да, 0 - Нет." << endl;
            cin >> answer;
        }
    }

    if (answer == 1)
    {
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                a[i][j] = c[i][j];//Копируем элементы
                m[i][j] = c[i][j];
            }
        }

        cout << "\n\n`````````````````````````````````````````````````````````````````````````````````````````````````````````\n";
        cout << "ПОКОЛЕНИЕ 0: " << endl << endl;
        for (int i = 0; i < rows; i++)//Выводим на экран двумерный динамический массив
        {
            for (int j = 0; j < cols; j++)
            {
                if (m[i][j] == 1)//Меняем цвет живых клеток на красный
                {
                    SetConsoleTextAttribute(description, FOREGROUND_RED);
                    cout << m[i][j] << "\t";
                    SetConsoleTextAttribute(description, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
                }
                else cout << m[i][j] << "\t";
            }
            cout << endl << endl << endl;
        }

        int h = 1;
        int p = 0;//Для счёта единиц(живых клеток)
        while (h <= g)//Счёт поколений
        {
            cout << "\n`````````````````````````````````````````````````````````````````````````````````````````````````````````\n";
            cout << "ПОКОЛЕНИЕ: " << h << endl << endl;
            for (int i = 0; i < rows; i++)//Выводим на экран двумерный динамический массив
            {
                for (int j = 0; j < cols; j++)
                {
                    if (i == 0 && j == 0)//Верхний левый угол матрицы
                    {
                        p = 0;
                        if (a[i][j + 1] == 1) ++p;//Право
                        if (a[i + 1][j] == 1) ++p;//Низ
                        if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i == 0 && j == (cols - 1))//Верхний правый угол матрицы
                    {
                        p = 0;
                        if (a[i][j - 1] == 1) ++p;//Лево
                        if (a[i + 1][j] == 1) ++p;//Низ
                        if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i == (rows - 1) && j == 0)//Нижний левый угол матрицы
                    {
                        p = 0;
                        if (a[i - 1][j] == 1) ++p;//Верх
                        if (a[i][j + 1] == 1) ++p;//Право
                        if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i == (rows - 1) && j == (cols - 1))//Нижний правый угол матрицы
                    {
                        p = 0;
                        if (a[i - 1][j] == 1) ++p;//Верх
                        if (a[i][j - 1] == 1) ++p;//Лево
                        if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i == 0 && j != 0 && j != (cols - 1))//Верхняя граница матрицы
                    {
                        p = 0;
                        if (a[i][j - 1] == 1) ++p;//Лево
                        if (a[i][j + 1] == 1) ++p;//Право
                        if (a[i + 1][j] == 1) ++p;//Низ
                        if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол
                        if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i != 0 && i != (rows - 1) && j == 0)//Левая граница матрицы
                    {
                        p = 0;
                        if (a[i - 1][j] == 1) ++p;//Верх
                        if (a[i][j + 1] == 1) ++p;//Право
                        if (a[i + 1][j] == 1) ++p;//Низ
                        if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол
                        if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i == (rows - 1) && j != 0 && j != (cols - 1))//Нижняя граница матрицы
                    {
                        p = 0;
                        if (a[i][j - 1] == 1) ++p;//Лево
                        if (a[i - 1][j] == 1) ++p;//Верх
                        if (a[i][j + 1] == 1) ++p;//Право
                        if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                        if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i != 0 && i != (rows - 1) && j == (cols - 1))//Правая граница матрицы
                    {
                        p = 0;
                        if (a[i - 1][j] == 1) ++p;//Верх
                        if (a[i][j - 1] == 1) ++p;//Лево
                        if (a[i + 1][j] == 1) ++p;//Низ
                        if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                        if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }
                    }

                    if (i != 0 && i != (rows - 1) && j != 0 && j != (cols - 1))//Середина матрицы
                    {
                        p = 0;
                        if (a[i - 1][j] == 1) ++p;//Верх
                        if (a[i][j - 1] == 1) ++p;//Лево
                        if (a[i + 1][j] == 1) ++p;//Низ
                        if (a[i][j + 1] == 1) ++p;//Право
                        if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                        if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол
                        if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол
                        if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                        if (a[i][j] == 0 && p == 3)//Условие d)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                        {
                            m[i][j] = 1;
                        }
                        if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                        {
                            m[i][j] = 0;
                        }

                    }
                    if (m[i][j] == 1)//Меняем цвет живых клеток на красный
                    {
                        SetConsoleTextAttribute(description, FOREGROUND_RED);
                        cout << m[i][j] << "\t";
                        SetConsoleTextAttribute(description, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);
                    }
                    else cout << m[i][j] << "\t";
                }
                cout << endl << endl << endl;
            }

            for (int i = 0; i < rows; i++)//Обновляем копируемый массив
            {
                for (int j = 0; j < cols; j++)
                {
                    a[i][j] = m[i][j];
                }
            }
            h++;// + поколение
        }
    }

    if (answer == 0)
    {
        cout << "\nСпасибо за игру!\n\n";
    }


    /////////////////////////// ОЧИСТКА /////////////////////////////

    for (int i = 0; i < rows; i++)//Удаление динамических массивов
    {
        delete[] m[i];
    }

    for (int i = 0; i < rows; i++)
    {
        delete[] a[i];
    }

    for (int i = 0; i < rows; i++)
    {
        delete[] c[i];
    }

    delete[] m;//Удаление *динамического массива с указателями* на *динамические массивы*
    delete[] a;
    delete[] c;

    return 0;
}