#include <ctime>
#include <iostream>
#include <windows.h>
#include "stdio.h"

using namespace std;

int main()
{
    setlocale(LC_ALL, "ru");
    srand(time(0));

    int** m;//Двумерный динамический массив
    int rows, cols;//строки, столбцы
    int** a;
    int ROWS, COLS;
    int n, g;//размерность поля

    cout << "Введите размерность поля игры << Жизнь >>, где 3 - 3х3, 5 - 5х5 и т.д.: ";
    cin >> n;
    rows = cols = n;//строки = столбцы

    cout << "\n---------------------------------------------------------------------------------------------------------\n";
    printf("|\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| ОПИСАНИЕ:\t\t\t\t\t\t\t\t\t\t\t\t|\n|\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| В игре << Жизнь >> есть живые клетки(обозначаются как 1) и мёртвые(обозначаются как 0)\t\t|\n|\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| УСЛОВИЯ:\t\t\t\t\t\t\t\t\t\t\t\t|");
    printf("\n| 1) Живая клетка, возле которой меньше двух живых клеток, умирает от одиночества;\t\t\t|");
    printf("\n| 2) Живая клетка, возле которой есть две или три живые клетки, выживает ещё на одно поколение;\t\t|");
    printf("\n| 3) Живая клетка, возле которой находится больше трёх живых клеток, умирает от перенаселения;\t\t|");
    printf("\n| 4) Мёртвая клетка, рядом с которой есть ровно три живых соседа, оживает.\t\t\t\t|");

    cout << "\n---------------------------------------------------------------------------------------------------------\n";

    cout << "Введите число поколений: ";
    cin >> g;
    cout << "Количество поколений: " << g;

    m = new int* [rows];//Создаём динамический массив указателей размером количества СТРОК
    a = new int* [rows];

    for (int i = 0; i < rows; i++)
    {
        m[i] = new int[cols];//Присваиваем элементам указателей новые динамические массивы размером количества СТОЛБЦОВ
    }

    for (int i = 0; i < rows; i++)//Заполняем двумерный динамический массив числами
    {
        for (int j = 0; j < cols; j++)
        {
            m[i][j] = rand() % 2;//Ограничиваем значение до 2, где 0 - неживая, 1 - живая.
        }
    }

    //////////////////////// КОПИРУЕМ ЭЛЕМЕНТЫ МАССИВА /////////////////////////////////

    for (int i = 0; i < rows; i++)
    {
        a[i] = new int[cols];//Присваиваем элементам указателей новые динамические массивы размером количества СТОЛБЦОВ
    }

    for (int i = 0; i < rows; i++)
    {
        for (int j = 0; j < cols; j++)
        {
            a[i][j] = m[i][j];//Копируем элементы
        }
    }
    
    ////////////////////////////////////////////////////////////////////////////////////

    cout << "\n\n`````````````````````````````````````````````````````````````````````````````````````````````````````````\n";
    cout << "ПОКОЛЕНИЕ 0: " << endl << endl;
    for (int i = 0; i < rows; i++)//Выводим на экран двумерный динамический массив
    {
        for (int j = 0; j < cols; j++)
        {
            cout << m[i][j] << "\t";
        }
        cout << endl << endl << endl;
    }

    /////////////////////////// ИГРА /////////////////////////////

    int h = 1;
    int p = 0;//Для счёта единиц(живых клеток)
    while (h <= g)//Счёт поколений
    {
        cout << "\n\n`````````````````````````````````````````````````````````````````````````````````````````````````````````\n";
        cout << "ПОКОЛЕНИЕ: " << h << endl << endl;
        for (int i = 0; i < rows; i++)//Выводим на экран двумерный динамический массив
        {
            for (int j = 0; j < cols; j++)
            {
                if (i == 0 && j == 0)//Верхний левый угол матрицы
                {
                    p = 0;
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == 0 && j == (cols - 1))//Верхний правый угол матрицы
                {
                    p = 0;
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == (rows - 1) && j == 0)//Нижний левый угол матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == (rows - 1) && j == (cols - 1))//Нижний правый угол матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == 0 && j != 0 && j != (cols - 1))//Верхняя граница матрицы
                {
                    p = 0;
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i != 0 && i != (rows - 1) && j == 0)//Левая граница матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i == (rows - 1) && j != 0 && j != (cols - 1))//Нижняя граница матрицы
                {
                    p = 0;
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i != 0 && i != (rows - 1) && j == (cols - 1))//Правая граница матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }
                }

                if (i != 0 && i != (rows - 1) && j != 0 && j != (cols - 1))//Середина матрицы
                {
                    p = 0;
                    if (a[i - 1][j] == 1) ++p;//Верх
                    if (a[i][j - 1] == 1) ++p;//Лево
                    if (a[i + 1][j] == 1) ++p;//Низ
                    if (a[i][j + 1] == 1) ++p;//Право
                    if (a[i - 1][j - 1] == 1) ++p;//Верхний левый угол
                    if (a[i + 1][j - 1] == 1) ++p;//Нижний левый угол
                    if (a[i - 1][j + 1] == 1) ++p;//Верхний правый угол
                    if (a[i + 1][j + 1] == 1) ++p;//Нижний правый угол

                    if (a[i][j] == 0 && p == 3)//Условие d)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p == 2 || a[i][j] == 1 && p == 3)//Условие b)
                    {
                        m[i][j] = 1;
                    }
                    if (a[i][j] == 1 && p < 2 || a[i][j] == 1 && p>3)//Условие a), c)
                    {
                        m[i][j] = 0;
                    }

                }
               
                cout << m[i][j] << "\t";
            }
            cout << endl << endl << endl;
        }

        for (int i = 0; i < rows; i++)//Обновляем копируемый массив
        {
            for (int j = 0; j < cols; j++)
            {
                a[i][j] = m[i][j];
            }
        }
        h++;// + поколение
    }


    /////////////////////////// ОЧИСТКА /////////////////////////////

    for (int i = 0; i < rows; i++)//Удаление динамических массивов
    {
        delete[] m[i];
    }

    for (int i = 0; i < rows; i++)
    {
        delete[] a[i];
    }

    delete[] m;//Удаление *динамического массива с указателями* на *динамические массивы*
    delete[] a;

    return 0;
}